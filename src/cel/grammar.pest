// Cello: Pest Grammar for Common Expression Language (CEL)
// 
// This grammar precisely follows the CEL specification from:
// https://github.com/google/cel-spec/blob/master/doc/langdef.md
//
// Each rule includes a comment referencing the corresponding line in langdef.md
// to ensure traceability and conformance verification.

// =============================================================================
// Top-Level Expression Grammar (langdef.md lines 27-51)
// =============================================================================

// CEL Spec (line 27): Expr = ConditionalOr ["?" ConditionalOr ":" Expr]
expr = { conditional_or ~ ("?" ~ conditional_or ~ ":" ~ expr)? }

// CEL Spec (line 28): ConditionalOr = [ConditionalOr "||"] ConditionalAnd
conditional_or = { conditional_and ~ ("||" ~ conditional_and)* }

// CEL Spec (line 29): ConditionalAnd = [ConditionalAnd "&&"] Relation
conditional_and = { relation ~ ("&&" ~ relation)* }

// CEL Spec (line 30): Relation = [Relation Relop] Addition
relation = { addition ~ (relop ~ addition)* }

// CEL Spec (line 31): Relop = "<" | "<=" | ">=" | ">" | "==" | "!=" | "in"
// Note: Order matters in PEG! Must try "<=" before "<" to avoid incorrect match.
// The "in" keyword requires a word boundary check to avoid matching prefix of identifiers like "infix".
relop = { "<=" | ">=" | "==" | "!=" | "<" | ">" | in_kw }

// "in" keyword with word boundary check
in_kw = @{ "in" ~ !ident_cont }

// CEL Spec (line 32): Addition = [Addition ("+" | "-")] Multiplication
// NOTE: add_op is a disambiguation rule that does not appear in langdef.md.
// It exists because PEST only emits pairs for named rules, not for literal tokens.
addition = { multiplication ~ (add_op ~ multiplication)* }
add_op = { "+" | "-" }

// CEL Spec (line 33): Multiplication = [Multiplication ("*" | "/" | "%")] Unary
// NOTE: mul_op is a disambiguation rule that does not appear in langdef.md.
// It exists because PEST only emits pairs for named rules, not for literal tokens.
multiplication = { unary ~ (mul_op ~ unary)* }
mul_op = { "*" | "/" | "%" }

// CEL Spec (lines 34-37): Unary = Member | "!" {"!"} Member | "-" {"-"} Member
// NOTE: not_unary and neg_unary are disambiguation rules that do not appear in langdef.md.
// They exist because PEST only emits pairs for named rules, not for literal tokens.
// IMPORTANT: member must be first to allow negative literals like -9223372036854775808 to be
// parsed as int_lit rather than Unary(Negate, ...) which would overflow.
unary = {
    member
  | not_unary
  | neg_unary  
}
not_unary = { "!"+ ~ member }
neg_unary = { "-"+ ~ member }

// CEL Spec (lines 38-41): Member = Primary | Member "." SELECTOR ["(" [ExprList] ")"] | Member "[" Expr "]"
// NOTE: member_suffix, field_access, index_access, and call_suffix are disambiguation rules
// that do not appear in langdef.md. They exist because PEST only emits pairs for named rules,
// not for literal tokens like "." or "[". Without these rules, the builder cannot distinguish
// field access from index access.
member = { primary ~ member_suffix* }

// Disambiguation rule: wraps field access or index access so builder can match on rule type
member_suffix = { field_access | index_access }

// Disambiguation rule: "." selector with optional method call arguments
field_access = { "." ~ selector ~ call_suffix? }

// Disambiguation rule: "[" expr "]" index operation
index_access = { "[" ~ expr ~ "]" }

// Disambiguation rule: "(" expr_list? ")" for method/function call arguments
call_suffix = { "(" ~ expr_list? ~ ")" }

// CEL Spec (lines 42-48): Primary = ["."] IDENT ["(" [ExprList] ")"] | ...
// NOTE: message_literal, ident_or_call, paren_expr, list_literal, and map_literal are
// disambiguation rules that do not appear in langdef.md. They exist because PEST only emits
// pairs for named rules, not for literal tokens like "(", "[", or "{". Without these rules,
// the builder cannot distinguish between the different primary expression forms.
// NOTE: Message literal MUST come before ident_or_call because PEG is greedy.
// If ident_or_call comes first, "Foo{}" would parse "Foo" as ident, leaving "{}" unparsed.
primary = {
    literal
  | message_literal
  | ident_or_call
  | paren_expr
  | list_literal
  | map_literal
}

// Disambiguation rule: Type{field: value} or pkg.Type{field: value}
message_literal = { "."? ~ selector ~ ("." ~ selector)* ~ "{" ~ field_inits? ~ ","? ~ "}" }

// Disambiguation rule: identifier or function call with optional leading dot
ident_or_call = { "."? ~ ident ~ call_suffix? }

// Disambiguation rule: parenthesized expression
paren_expr = { "(" ~ expr ~ ")" }

// Disambiguation rule: list literal [expr, ...]
list_literal = { "[" ~ expr_list? ~ ","? ~ "]" }

// Disambiguation rule: map literal {key: value, ...}
map_literal = { "{" ~ map_inits? ~ ","? ~ "}" }

// CEL Spec (line 49): ExprList = Expr {"," Expr}
expr_list = { expr ~ ("," ~ expr)* }

// CEL Spec (line 50): FieldInits = SELECTOR ":" Expr {"," SELECTOR ":" Expr}
field_inits = { selector ~ ":" ~ expr ~ ("," ~ selector ~ ":" ~ expr)* }

// CEL Spec (line 51): MapInits = Expr ":" Expr {"," Expr ":" Expr}
map_inits = { expr ~ ":" ~ expr ~ ("," ~ expr ~ ":" ~ expr)* }

// =============================================================================
// CEL Character Classes (langdef.md lines 99-100, 106-107)
// =============================================================================
// We define CEL's character classes explicitly rather than using PEST's built-in
// ASCII_* classes to ensure exact conformance with the CEL specification.

// CEL Spec (line 100): [_a-zA-Z] - valid first character of an identifier
ident_start = { "_" | 'a'..'z' | 'A'..'Z' }

// CEL Spec (line 100): [_a-zA-Z0-9] - valid continuation character of an identifier
ident_cont = { "_" | 'a'..'z' | 'A'..'Z' | '0'..'9' }

// CEL Spec (line 106): DIGIT = [0-9]
cel_digit = { '0'..'9' }

// CEL Spec (line 107): HEXDIGIT = [0-9abcdefABCDEF]
cel_hexdigit = { '0'..'9' | 'a'..'f' | 'A'..'F' }

// =============================================================================
// Lexical Rules (langdef.md lines 99-127)
// =============================================================================

// CEL Spec (line 99): IDENT = SELECTOR - RESERVED
// PEG simulation of set subtraction: match SELECTOR but reject if it's a RESERVED word.
// A word is reserved only if the keyword is NOT followed by an identifier continuation char.
ident = @{ 
    !(reserved ~ !ident_cont) ~ selector
}

// CEL Spec (line 100): SELECTOR = [_a-zA-Z][_a-zA-Z0-9]* - KEYWORD
// PEG simulation of set subtraction: match identifier pattern but reject if it's a KEYWORD.
// A word is a keyword only if NOT followed by an identifier continuation char.
selector = @{
    !(keyword ~ !ident_cont) ~ 
    ident_start ~ ident_cont*
}

// CEL Spec (lines 101-102): LITERAL = INT_LIT | UINT_LIT | FLOAT_LIT | STRING_LIT | BYTES_LIT | BOOL_LIT | NULL_LIT
literal = {
    float_lit    // Must come before int_lit to match decimal point
  | uint_lit     // Must come before int_lit to match 'u' suffix
  | int_lit
  | bytes_lit    // Must come before string_lit to match 'b' prefix
  | string_lit
  | bool_lit
  | null_lit
}

// CEL Spec (line 103): INT_LIT = -? DIGIT+ | -? 0x HEXDIGIT+
int_lit = @{
    "-"? ~ "0" ~ ("x" | "X") ~ cel_hexdigit+
  | "-"? ~ cel_digit+
}

// CEL Spec (line 104): UINT_LIT = INT_LIT [uU]
uint_lit = @{
    int_lit ~ ("u" | "U")
}

// CEL Spec (line 105): FLOAT_LIT = -? DIGIT* . DIGIT+ EXPONENT? | -? DIGIT+ EXPONENT
float_lit = @{
    "-"? ~ cel_digit* ~ "." ~ cel_digit+ ~ exponent?
  | "-"? ~ cel_digit+ ~ exponent
}

// CEL Spec (line 108): EXPONENT = [eE] [+-]? DIGIT+
exponent = @{
    ("e" | "E") ~ ("+" | "-")? ~ cel_digit+
}

// CEL Spec (lines 109-113): STRING_LIT = [rR]? ( "..." | '...' | """...""" | '''...''' )
// Escape sequences (\X) are recognized as a unit so they don't terminate the string.
// Escape processing happens after parsing.
// ESCAPE rule omitted from parser since not used
string_lit = @{
    ("r" | "R")? ~ (
        "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\""
      | "'''" ~ (!"'''" ~ ANY)* ~ "'''"
      | "\"" ~ ("\\" ~ ANY | !"\"" ~ !"\r" ~ !"\n" ~ ANY)* ~ "\""
      | "'" ~ ("\\" ~ ANY | !"'" ~ !"\r" ~ !"\n" ~ ANY)* ~ "'"
    )
}

// CEL Spec (line 114): BYTES_LIT = [bB] STRING_LIT
bytes_lit = ${ ("b" | "B") ~ string_lit }

// CEL Spec (line 120): BOOL_LIT = "true" | "false"
// NOTE: Must check word boundary (!ident_cont) to avoid matching prefix of identifiers like "trueish"
bool_lit = @{ ("true" | "false") ~ !ident_cont }

// CEL Spec (line 121): NULL_LIT = "null"
// NOTE: Must check word boundary (!ident_cont) to avoid matching prefix of identifiers like "null_type"
null_lit = @{ "null" ~ !ident_cont }

// CEL Spec (line 122): KEYWORD = BOOL_LIT | NULL_LIT | "in"
// NOTE: Keywords are only keywords when not followed by identifier continuation characters
keyword = @{
    ("true" | "false" | "null" | "in") ~ !ident_cont
}

// CEL Spec (lines 123-126): RESERVED = "as" | "break" | ...
// NOTE: Reserved words are only reserved when not followed by identifier continuation characters
reserved = @{
    ( "as" | "break" | "const" | "continue" | "else"
    | "for" | "function" | "if" | "import" | "let"
    | "loop" | "package" | "namespace" | "return"
    | "var" | "void" | "while"
    ) ~ !ident_cont
}

// CEL Spec (line 127): WHITESPACE = [\t\n\f\r ]+
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | "\x0C" }

// CEL Spec (line 128): COMMENT = '//' ~\n* \n
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }

// =============================================================================
// Entry Point
// =============================================================================

// The main entry point for parsing a complete CEL expression
cel = { SOI ~ expr ~ EOI }
