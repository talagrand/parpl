// Cello: Pest Grammar for Common Expression Language (CEL)
// 
// This grammar precisely follows the CEL specification from:
// https://github.com/google/cel-spec/blob/master/doc/langdef.md
//
// Each rule includes a comment referencing the corresponding line in langdef.md
// to ensure traceability and conformance verification.

// =============================================================================
// Top-Level Expression Grammar (langdef.md lines 27-51)
// =============================================================================

// CEL Spec (line 27): Expr = ConditionalOr ["?" ConditionalOr ":" Expr]
expr = { conditional_or ~ ("?" ~ conditional_or ~ ":" ~ expr)? }

// CEL Spec (line 28): ConditionalOr = [ConditionalOr "||"] ConditionalAnd
conditional_or = { conditional_and ~ ("||" ~ conditional_and)* }

// CEL Spec (line 29): ConditionalAnd = [ConditionalAnd "&&"] Relation
conditional_and = { relation ~ ("&&" ~ relation)* }

// CEL Spec (line 30): Relation = [Relation Relop] Addition
relation = { addition ~ (relop ~ addition)* }

// CEL Spec (line 31): Relop = "<" | "<=" | ">=" | ">" | "==" | "!=" | "in"
// Note: Order matters in PEG! Must try "<=" before "<" to avoid incorrect match.
// The "in" keyword requires a word boundary check to avoid matching prefix of identifiers like "infix".
relop = { "<=" | ">=" | "==" | "!=" | "<" | ">" | in_kw }

// "in" keyword with word boundary check
in_kw = @{ "in" ~ !ident_cont }

// CEL Spec (line 32): Addition = [Addition ("+" | "-")] Multiplication
addition = { multiplication ~ (("+" | "-") ~ multiplication)* }

// CEL Spec (line 33): Multiplication = [Multiplication ("*" | "/" | "%")] Unary
multiplication = { unary ~ (("*" | "/" | "%") ~ unary)* }

// CEL Spec (lines 34-37): Unary = Member | "!" {"!"} Member | "-" {"-"} Member
unary = {
    member
  | "!"+ ~ member
  | "-"+ ~ member
}

// CEL Spec (lines 38-41): Member = Primary | Member "." SELECTOR ["(" [ExprList] ")"] | Member "[" Expr "]"
// The member rule handles field access and indexing operations on a primary expression
member = {
    primary ~ (
        "." ~ selector ~ ("(" ~ expr_list? ~ ")")?
      | "[" ~ expr ~ "]"
    )*
}

// CEL Spec (lines 42-48): Primary = ["."] IDENT ["(" [ExprList] ")"] | ...
// NOTE: Message literal MUST come before ident rule because PEG is greedy (spec has ident rule first).
// If ident comes first, "Foo{}" would parse "Foo" as ident, leaving "{}" unparsed.
primary = {
    literal                                              // Literal value (try first to avoid 'r' or 'b' being parsed as identifiers)
  | "."? ~ selector ~ ("." ~ selector)* ~ "{" ~ field_inits? ~ ","? ~ "}"  // Message literal (must precede ident!)
  | "."? ~ ident ~ ("(" ~ expr_list? ~ ")")?            // Function call or identifier
  | "(" ~ expr ~ ")"                                     // Parenthesized expression
  | "[" ~ expr_list? ~ ","? ~ "]"                        // List literal
  | "{" ~ map_inits? ~ ","? ~ "}"                        // Map literal
}

// CEL Spec (line 49): ExprList = Expr {"," Expr}
expr_list = { expr ~ ("," ~ expr)* }

// CEL Spec (line 50): FieldInits = SELECTOR ":" Expr {"," SELECTOR ":" Expr}
field_inits = { selector ~ ":" ~ expr ~ ("," ~ selector ~ ":" ~ expr)* }

// CEL Spec (line 51): MapInits = Expr ":" Expr {"," Expr ":" Expr}
map_inits = { expr ~ ":" ~ expr ~ ("," ~ expr ~ ":" ~ expr)* }

// =============================================================================
// CEL Character Classes (langdef.md lines 99-100, 106-107)
// =============================================================================
// We define CEL's character classes explicitly rather than using PEST's built-in
// ASCII_* classes to ensure exact conformance with the CEL specification.

// CEL Spec (line 100): [_a-zA-Z] - valid first character of an identifier
ident_start = { "_" | 'a'..'z' | 'A'..'Z' }

// CEL Spec (line 100): [_a-zA-Z0-9] - valid continuation character of an identifier
ident_cont = { "_" | 'a'..'z' | 'A'..'Z' | '0'..'9' }

// CEL Spec (line 106): DIGIT = [0-9]
cel_digit = { '0'..'9' }

// CEL Spec (line 107): HEXDIGIT = [0-9abcdefABCDEF]
cel_hexdigit = { '0'..'9' | 'a'..'f' | 'A'..'F' }

// =============================================================================
// Lexical Rules (langdef.md lines 99-127)
// =============================================================================

// CEL Spec (line 99): IDENT = SELECTOR - RESERVED
// PEG simulation of set subtraction: match SELECTOR but reject if it's a RESERVED word.
// A word is reserved only if the keyword is NOT followed by an identifier continuation char.
ident = @{ 
    !(reserved ~ !ident_cont) ~ selector
}

// CEL Spec (line 100): SELECTOR = [_a-zA-Z][_a-zA-Z0-9]* - KEYWORD
// PEG simulation of set subtraction: match identifier pattern but reject if it's a KEYWORD.
// A word is a keyword only if NOT followed by an identifier continuation char.
selector = @{
    !(keyword ~ !ident_cont) ~ 
    ident_start ~ ident_cont*
}

// CEL Spec (lines 101-102): LITERAL = INT_LIT | UINT_LIT | FLOAT_LIT | STRING_LIT | BYTES_LIT | BOOL_LIT | NULL_LIT
literal = {
    float_lit    // Must come before int_lit to match decimal point
  | uint_lit     // Must come before int_lit to match 'u' suffix
  | int_lit
  | bytes_lit    // Must come before string_lit to match 'b' prefix
  | string_lit
  | bool_lit
  | null_lit
}

// CEL Spec (line 103): INT_LIT = -? DIGIT+ | -? 0x HEXDIGIT+
int_lit = @{
    "-"? ~ "0" ~ ("x" | "X") ~ cel_hexdigit+
  | "-"? ~ cel_digit+
}

// CEL Spec (line 104): UINT_LIT = INT_LIT [uU]
uint_lit = @{
    int_lit ~ ("u" | "U")
}

// CEL Spec (line 105): FLOAT_LIT = -? DIGIT* . DIGIT+ EXPONENT? | -? DIGIT+ EXPONENT
float_lit = @{
    "-"? ~ cel_digit* ~ "." ~ cel_digit+ ~ exponent?
  | "-"? ~ cel_digit+ ~ exponent
}

// CEL Spec (line 108): EXPONENT = [eE] [+-]? DIGIT+
exponent = @{
    ("e" | "E") ~ ("+" | "-")? ~ cel_digit+
}

// CEL Spec (lines 109-113): STRING_LIT = [rR]? ( "..." | '...' | """...""" | '''...''' )
// Escape sequences (\X) are recognized as a unit so they don't terminate the string.
// Escape processing happens after parsing.
// ESCAPE rule omitted from parser since not used
string_lit = @{
    ("r" | "R")? ~ (
        "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\""
      | "'''" ~ (!"'''" ~ ANY)* ~ "'''"
      | "\"" ~ ("\\" ~ ANY | !"\"" ~ !"\r" ~ !"\n" ~ ANY)* ~ "\""
      | "'" ~ ("\\" ~ ANY | !"'" ~ !"\r" ~ !"\n" ~ ANY)* ~ "'"
    )
}

// CEL Spec (line 114): BYTES_LIT = [bB] STRING_LIT
bytes_lit = ${ ("b" | "B") ~ string_lit }

// CEL Spec (line 120): BOOL_LIT = "true" | "false"
// NOTE: Must check word boundary (!ident_cont) to avoid matching prefix of identifiers like "trueish"
bool_lit = @{ ("true" | "false") ~ !ident_cont }

// CEL Spec (line 121): NULL_LIT = "null"
// NOTE: Must check word boundary (!ident_cont) to avoid matching prefix of identifiers like "null_type"
null_lit = @{ "null" ~ !ident_cont }

// CEL Spec (line 122): KEYWORD = BOOL_LIT | NULL_LIT | "in"
// NOTE: Keywords are only keywords when not followed by identifier continuation characters
keyword = @{
    ("true" | "false" | "null" | "in") ~ !ident_cont
}

// CEL Spec (lines 123-126): RESERVED = "as" | "break" | ...
// NOTE: Reserved words are only reserved when not followed by identifier continuation characters
reserved = @{
    ( "as" | "break" | "const" | "continue" | "else"
    | "for" | "function" | "if" | "import" | "let"
    | "loop" | "package" | "namespace" | "return"
    | "var" | "void" | "while"
    ) ~ !ident_cont
}

// CEL Spec (line 127): WHITESPACE = [\t\n\f\r ]+
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | "\x0C" }

// CEL Spec (line 128): COMMENT = '//' ~\n* \n
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }

// =============================================================================
// Entry Point
// =============================================================================

// The main entry point for parsing a complete CEL expression
cel = { SOI ~ expr ~ EOI }
